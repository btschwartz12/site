/*
  survey.js

  This contains all the necessary logic for updating, submitting, marshalling, and unmarshalling the survey data.

  This is basically all generated by ChatGPT, and I really don't care. I hate frontend stuff.
*/

class SelectQuestion {
  constructor(selectedOptions = []) {
    this.selectedOptions = selectedOptions;
  }

  marshal() {
    if (this.selectedOptions.length > 255) {
      throw new Error('Too many options');
    }
    const numOptions = this.selectedOptions.length;
    const bitVectorSize = Math.ceil(numOptions / 8);
    const bitVector = new Uint8Array(bitVectorSize);
    this.selectedOptions.forEach((selected, i) => {
      if (selected) {
        const byteIndex = Math.floor(i / 8);
        const bitPosition = 7 - (i % 8);
        bitVector[byteIndex] |= 1 << bitPosition;
      }
    });
    const payload = new Uint8Array(1 + bitVectorSize);
    payload[0] = numOptions;
    payload.set(bitVector, 1);
    return payload;
  }

  unmarshal(data) {
    if (!(data instanceof Uint8Array)) {
      throw new Error('Data must be a Uint8Array');
    }
    let offset = 0;
    if (data.length <= offset) {
      throw new Error('No data');
    }
    const numOptions = data[offset++];
    const bitVectorSize = Math.ceil(numOptions / 8);
    if (data.length < offset + bitVectorSize) {
      throw new Error('Invalid payload length');
    }
    const bitVector = data.slice(offset, offset + bitVectorSize);
    this.selectedOptions = new Array(numOptions);
    for (let i = 0; i < numOptions; i++) {
      const byteIndex = Math.floor(i / 8);
      const bitPosition = 7 - (i % 8);
      this.selectedOptions[i] = (bitVector[byteIndex] & (1 << bitPosition)) !== 0;
    }
  }
}

class SelectAllThatApplyQuestion extends SelectQuestion {
  constructor(selectedOptions = []) {
    super(selectedOptions);
  }

  marshal() {
    return super.marshal();
  }

  unmarshal(data) {
    super.unmarshal(data);
  }
}

class MultipleChoiceQuestion extends SelectQuestion {
  constructor(selectedOptions = []) {
    super(selectedOptions);
  }

  marshal() {
    const numSelected = this.selectedOptions.filter(Boolean).length;
    if (numSelected > 1) {
      throw new Error('Multiple options selected');
    }
    return super.marshal();
  }

  unmarshal(data) {
    super.unmarshal(data);
  }
}

class TextEntryQuestion {
  constructor(text = '') {
    this.text = text;
  }

  marshal() {
    const textEncoder = new TextEncoder();
    const textBytes = textEncoder.encode(this.text);
    if (textBytes.length > 255) {
      throw new Error('Text too long');
    }
    const payload = new Uint8Array(1 + textBytes.length);
    payload[0] = textBytes.length;
    payload.set(textBytes, 1);
    return payload;
  }

  unmarshal(data) {
    if (!(data instanceof Uint8Array)) {
      throw new Error('Data must be a Uint8Array');
    }
    let offset = 0;
    if (data.length <= offset) {
      throw new Error('No data');
    }
    const textLength = data[offset++];
    if (data.length < offset + textLength) {
      throw new Error('Invalid payload length');
    }
    const textDecoder = new TextDecoder();
    this.text = textDecoder.decode(data.slice(offset, offset + textLength));
  }
}

class Survey {
  constructor(version = 1, questions = {}) {
    this.version = version;
    this.questions = questions; // { id: Question }
  }

  marshal() {
    const buffers = [];
    buffers.push(Uint8Array.of(this.version));
    const questionIds = Object.keys(this.questions).map(id => parseInt(id));
    buffers.push(Uint8Array.of(questionIds.length));

    questionIds.forEach(id => {
      const question = this.questions[id];
      let questionType;
      let data;

      if (question instanceof MultipleChoiceQuestion) {
        questionType = 0;
        data = question.marshal();
      } else if (question instanceof SelectAllThatApplyQuestion) {
        questionType = 1;
        data = question.marshal();
      } else if (question instanceof TextEntryQuestion) {
        questionType = 2;
        data = question.marshal();
      } else {
        throw new Error(`Unknown question type for question ID ${id}`);
      }

      if (data.length > 255) {
        throw new Error(`Question data too long for question ID ${id}`);
      }
      const header = Uint8Array.of(id, questionType, data.length);
      buffers.push(header);
      buffers.push(data);
    });

    const totalLength = buffers.reduce((sum, b) => sum + b.length, 0);
    const payload = new Uint8Array(totalLength);
    let offset = 0;
    buffers.forEach(buffer => {
      payload.set(buffer, offset);
      offset += buffer.length;
    });
    return payload;
  }

  unmarshal(data) {
    if (!(data instanceof Uint8Array)) {
      throw new Error('Data must be a Uint8Array');
    }
    if (data.length < 2) {
      throw new Error('Data too short');
    }
    let offset = 0;
    this.version = data[offset++];
    const numQuestions = data[offset++];
    this.questions = {};

    for (let i = 0; i < numQuestions; i++) {
      if (offset + 3 > data.length) {
        throw new Error('Invalid question data header');
      }
      const id = data[offset++];
      const qType = data[offset++];
      const qLen = data[offset++];

      if (offset + qLen > data.length) {
        throw new Error(`Question payload is too short for id ${id}`);
      }
      const qData = data.slice(offset, offset + qLen);
      offset += qLen;

      let question;
      switch (qType) {
        case 0:
          question = new MultipleChoiceQuestion();
          break;
        case 1:
          question = new SelectAllThatApplyQuestion();
          break;
        case 2:
          question = new TextEntryQuestion();
          break;
        default:
          throw new Error(`Unknown question type ${qType}`);
      }

      question.unmarshal(qData);
      this.questions[id] = question;
    }
  }
}

function updateSurvey(survey) {
  for (const [id, question] of Object.entries(survey.questions)) {
      const questionID = `question_${id}`;

      if ((question instanceof MultipleChoiceQuestion) || (question instanceof SelectAllThatApplyQuestion)) {
          const inputs = document.getElementsByName(questionID);
          inputs.forEach((box, index) => {
              box.checked = question.selectedOptions[index] || false;
          });
      } else if (question instanceof TextEntryQuestion) {
          const input = document.getElementsByName(questionID)[0];
          if (input) {
              input.value = question.text;
          }
      }
  }
}

async function submitSurvey() {
  const surveyData = parseSurvey();
  const data = surveyData.marshal();

  try {
      const response = await fetch('/survey/update', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/octet-stream',
          },
          body: data,
      });

      if (response.ok) {
          const responseText = await response.text();
      } else {
          console.error('Server returned an error:', response.statusText);
      }
  } catch (error) {
      console.error('Failed to submit survey:', error);
  }
}
